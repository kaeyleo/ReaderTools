<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touch</title>
    <link rel="stylesheet" href="css/app.min.css">
    <style>
        body {
            background-color: #EEE8E5;
        }
        .data-bar {
            position: fixed;
            top: 0;
            right: 10%;
            width: 160px;
            padding: 6px 0;
            border-radius: 0 0 5px 5px;
            font-size: 18px;
            font-weight: lighter;
            color: #fff;
            text-align: center;
            background-color: rgba(0, 0, 0, .9);
        }
        .page {
            position: absolute;
            top: 0;
            left: 0;
            padding: 32px 24px;
        }
        .post {
            font-weight: 300;
            line-height: 1.75;
        }
        .side-tool {
            position: fixed;
            bottom: 30%;
            right: -50px;
            right: 0px;
            width: 60px;
            /*height: 160px;*/
            border-radius: 5px 0 0 5px;
            background-color: rgba(0, 0, 0, .8);
            z-index: 100;
            transition: .3s;
        }
        .side-tool-panel {
            margin: 0;
            padding: 0;
            text-align: center
        }
        .side-tool-panel li {
            list-style: none;
            color: #fff;
            font-weight: lighter;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, .3);
        }
        .side-tool-panel li:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <span class="data-bar" id="show">X: 0, Y: 0</span>
    <div class="side-tool">
        <ul class="side-tool-panel">
            <li data-action="jump-top">回顶</li>
            <li data-action="day-mode">夜间</li>
        </ul>
    </div>
    <div class="page">
        <h2>从零开始编写自己的JavaScript框架（一）</h2>
        <p class="post">
            一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。<br><br
            >先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？<br><br>我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。<br><br>
            考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。<br><br>
            JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？<br><br>
            那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。<br><br>
            我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过： C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！” Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！” C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！
        </p>
    </div>
    <script src="js/app.min.js"></script>
    <script>
        var text_el = document.querySelector('#show'),
            sideTool = document.querySelector('.side-tool'),
            page = document.querySelector('.page'),
            el = document.body;

        var start_point = {}, end_point = {};
        
        // sideTool.style.right = '-50px';
        /**
        *   触发事件
        */
        el.addEventListener('touchmove', function(evt){
            var x = evt.targetTouches[0].clientX;
            var y = evt.targetTouches[0].clientY;
            text_el.innerHTML = 'X: ' + x + ', Y: ' + y;
        });

        el.addEventListener('touchstart', function(evt){
            var t = evt.changedTouches[0];
            start_point.x = t.clientX;
            start_point.y = t.clientY;
        });

        el.addEventListener('touchend', function(evt){
            var t = evt.changedTouches[0];
            end_point.x = t.clientX;
            end_point.y = t.clientY;
            var p = getMovingRange(start_point, end_point);

            // console.info({
            //     'START': start_point.x + ', ' + start_point.y,
            //     'END': end_point.x + ', ' + end_point.y,
            //     'Range': p.x
            // });

            if(p.x >= 80 && sideTool.style.right == '-50px') {
                sideTool.style.right = '0px';
            }else if(p.x <= -80 && sideTool.style.right == '0px') {
                sideTool.style.right = '-50px';
            }

        });

        // 计算水平距离
        function getMovingRange(p1, p2) {
            var p = {};
            p.x = p1.x - p2.x;
            p.y = p1.y - p2.y;
            return p;
        }

        // 操作
        function jumpTop() {
            console.log();
        }

        function dayNightMode(el) {
            
        }

        var side_el = document.querySelector('.side-tool-panel');
        side_el.addEventListener('click', function(evt){
            if(evt.target.nodeName == 'LI') {
                var actFlag = evt.target.dataset.action;
                console.log(actFlag);
                if(actFlag==='day-mode'||actFlag==='night-mode') {
                    page.toggleClass('add');
                }
            }
        });

        /**
        *   Helper 工具函数
        */

        // 遍历
        function each(cb) {
            
        }

        // 添加类名
        function addClass(className) {
            var self = this;
            if(!(self instanceof HTMLElement) || !self.className || typeof className !== 'string') {
                return;
            }

            if(self.hasClass(className)) {
                self.className = ' ' + className;
            }else{
                self.className = className;
            }
        }
        // 移除类名
        function removeClass(className) {
            var self = this;
            if(!(self instanceof HTMLElement) || !self.className || typeof className !== 'string') {
                return;
            }

        }
        // 查询对象是否有指定类名
        function hasClass(className) {
            var self = this;
            if(!(self instanceof HTMLElement) || !self.className || typeof className !== 'string') {
                return;
            }


		}
        // 切换类名
        function toggleClass(className){  
            var self = this;
            if(!(self instanceof HTMLElement) || !self.className) {
                return;
            }

            if(self.hasClass(className)) {
                self.removeClass(className);
            }else{
                self.addClass(className);
            }

            return self.className;
        }

        Object.prototype.addClass = addClass;
        Object.prototype.hasClass = hasClass;
        Object.prototype.toggleClass = toggleClass;




    </script>
</body>
</html>